options {
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(MyParser)
import java.util.ArrayList;import java.util.HashMap;
import java.util.Map;



class MyParser {
    private static Map<String, ArrayList<String>> symbolTable;

  public static void main( String[] args ) throws ParseException, TokenMgrError {
        boolean debug = true;
        MyParser parser = new MyParser( System.in ) ;
        symbolTable = new HashMap<String, ArrayList<String>>();
        if (!debug) parser.disable_tracing();
        try {
            parser.program();
        } catch(ParseException e) {
            System.err.println(e.getMessage());
        }

        for (ArrayList<String> list : symbolTable.values()) {

            System.out.println("nome: " + list.get(0));
//            System.out.println("tipo: " + list.get(1));
            System.out.println("ocorrencias: " + list.get(1));
            System.out.println();
        }
    }
}

PARSER_END(MyParser)

SKIP : { " " | "\n" | "\r" | "\r\n" }

/* Palavras reservadas */
TOKEN:
{
  < INT: "int" >
| < FLOAT: "float" >
| < STRING: "string" >
| < DEF: "def" >
| < BREAK: "break" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < NEW: "new" >
| < NULL: "null" >
| < IF: "if" >
| < ELSE: "else" >
| < FOR: "for" >
}

/* Operadores */
TOKEN:
{
  < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < OPENP: "(">
| < CLOSEP: ")" >
| < OPENCB: "{" >
| < CLOSECB: "}" >
| < OPENB: "[" >
| < CLOSEB: "]" >
| < SEMIC: ";" >
| < COMMA: "," >
| < EQUALS: "==" >
| < ASSIGN: "=" >
| < GREAT: ">" >
| < LESS: "<" >
| < GREATEQ: ">=" >
| < LESSEQ: "<=" >
| < DIFF: "!=" >
| < MOD: "%" >
}

/* Identificadores */
TOKEN :
{
  <#LETTER: ["a" - "z", "A" - "Z"]>
| <#DIGIT: ["0"-"9"]>
| < ID: <LETTER> (<LETTER> | <DIGIT>)* >
| < INT_CONST: (<DIGIT>)+ >
| < FLOAT_CONST: (<DIGIT>)* "."(<DIGIT>)+ >
| < STRING_CONST: "\"" (~["\""])* "\"" >
}

void id(String type):
{Token t;}
{
    t=<ID> {
    if (symbolTable.containsKey(t.image)) {
        Integer symbolCount = Integer.valueOf(symbolTable.get(t.image).get(1));
        symbolCount++;
        symbolTable.get(t.image).set(1, symbolCount.toString());
    } else {
        ArrayList<String> data = new ArrayList<String>();
        data.add(t.image);
//        data.add(type);
        data.add("1");
        symbolTable.put(t.image, data);
    }
}
}

void program():
{}
{
    funclist() | statement() | {} {}<EOF>
}

void funclist():
{}
{
    funcdef() funclist2()
}

void funclist2():
{}
{
    funclist() | {}
}

void funcdef():
{}
{
    <DEF> id("function") <OPENP> paramlist() <CLOSEP> <OPENCB> statelist() <CLOSECB>
}

void paramlist():
{}
{
    (<INT> | <FLOAT> | <STRING> ) id("parameter") <COMMA> paramlist2() | {}
}

void paramlist2():
{}
{
    <COMMA> paramlist() | {}
}

void statement():
{}
{
    vardecl() <SEMIC> | atribstat() <SEMIC> | printstat() <SEMIC> | readstat() <SEMIC> | returnstat() <SEMIC> | ifstat() | forstat() | <OPENCB> statelist() <CLOSECB> | <BREAK> <SEMIC> | <SEMIC>
}

void vardecl():
{}
{
    ( <INT> | <FLOAT> | <STRING>) id("variable") ic()
}

void ic():
{}
{
    <OPENB> <INT_CONST> <CLOSEB> ic() | {}
}

void atribstat():
{}
{
    lvalue() <ASSIGN> (LOOKAHEAD(2) expression() | allocexpression() | funccal())
}

void funccal():
{}
{
    id("function") <OPENP> paramlistcall() <CLOSEP>
}

void paramlistcall():
{}
{
    id("parameter") paramlistcall2() | {}
}

void paramlistcall2():
{}
{
    <COMMA> paramlistcall() | {}
}

void printstat():
{}
{
    <PRINT> expression()
}
void readstat():
{}
{
    <READ> lvalue()
}

void returnstat():
{}
{
    <RETURN>
}

void ifstat():
{}
{
    <IF> <OPENP> expression() <CLOSEP> statement() es()
}

void es():
{}
{
    <ELSE> statement() | {}
}

void forstat():
{}
{
    <FOR> <OPENP> atribstat()<SEMIC> expression() <SEMIC> atribstat() <CLOSEP> statement()
}

void statelist():
{}
{
    statement() sl()
}

void sl():
{}
{
    statelist() | {}
}

void allocexpression():
{}
{
    <NEW> (<INT> | <FLOAT> | <STRING>) ne()
}

void ne():
{}
{
    <OPENB> numexpression() <CLOSEB> (ne() | {})
}

void expression():
{}
{
    numexpression() ned()
}

void ned():
{}
{
    (<LESS> | <GREAT> | <LESSEQ> | <GREATEQ> | <EQUALS> | <DIFF> ) numexpression() | {}
}

void numexpression():
{}
{
    term() ner()
}

void ner():
{}
{
    (<PLUS> | <MINUS> ) term() ner() | {}
}

void term():
{}
{
    unaryexpr() ue()
}

void ue():
{}
{
    (<MULT> | <DIV> | <MOD> ) unaryexpr() ue() | {}
}

void unaryexpr():
{}
{
    mn() factor()
}

void mn():
{}
{
    <PLUS> | <MINUS> | {}
}

void factor():
{}
{
    <INT_CONST> | <FLOAT_CONST> | <STRING_CONST> | <NULL> | lvalue() | <OPENP> numexpression() <CLOSEP>
}

void lvalue():
{}
{
   id("lvalue") net()
}

void net():
{}
{
    <OPENB> numexpression() <CLOSEB> net() | {}
}