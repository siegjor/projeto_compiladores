// Grupo:
// - Cleberton Oliveira (17205083)
// - Gabriel Bristot Loli (20100844)
// - Kevin Rafael Velez Bernal (20102279)

options {
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(MyParser)
import org.example.CustomTreeNode;import java.util.ArrayList;import java.util.HashMap;
import java.util.Map;

class MyParser {
    private static Map<String, ArrayList<String>> symbolTable;
    private static ArrayList<String> tokenList;
    private static StringBuilder sententialForm = new StringBuilder();
    private static ArrayList<HashMap<String, Boolean>> sententialFormList;
    private static ArrayList<HashMap<String, Boolean>> removedTokens;

  public static void main( String[] args ) throws ParseException, TokenMgrError {
        // Habilite essa opção para gerar o log da árvore sintática
        boolean debug = false;

        // Usados para saber se houve erros na execução
        boolean hasLexicalError = false;
        boolean hasSyntaxError = false;

        MyParser parser = new MyParser( System.in ) ;
        symbolTable = new HashMap<String, ArrayList<String>>();
        tokenList = new ArrayList<String>();
        sententialFormList = new ArrayList<HashMap<String, Boolean>>();
        removedTokens = new ArrayList<HashMap<String, Boolean>>();
        CustomTreeNode treeNode = new CustomTreeNode();

        if (!debug) parser.disable_tracing();

        // Cabeçalho
        System.out.println("\n-------------------------------------------");
        System.out.println(">>> Trabalho feito por:");
        System.out.println("--> Cleberton Oliveira (17205083)");
        System.out.println("--> Gabriel Bristot Loli (20100844)");
        System.out.println("--> Kevin Rafael Velez Bernal (20102279)");
        System.out.println("-------------------------------------------\n");

        boolean emptyInput = false;
        try {
            // Executa o parser
            parser.program();
        } catch (ParseException e) {
            // Em caso de erro na análise sintática
            hasSyntaxError = true;
            if (parser.token == null) {
                emptyInput = true;
            } else {

                    System.out.println("AAAAAAAAAAAAAAAAAAA" + treeNode.getCount());

                System.out.println("\nErro de análise sintática: " + e.getMessage());
                System.out.println("Falha na linha: " + e.currentToken.beginLine + ", coluna: " + e.currentToken.beginColumn);
                System.out.println("Forma sentencial alfa: " + sententialForm.toString());
                System.out.println("Símbolo não-terminal mais à esquerda de alfa: " + e.currentToken.next.image);
                System.out.println("Token da entrada que causou o erro: " + e.currentToken.image + "\n");
            }
        } catch (TokenMgrError e) {
            // Em caso de erro na análise léxica
            hasLexicalError = true;
            System.out.println("\nErro de análise léxica: " + e.getMessage());
        }

        if (emptyInput) {
            System.out.println("Erro de análise sintática: entrada vazia na tabela de reconhecimento");
        }

        if (!hasLexicalError) {
            System.out.println("\n>> Successo! Sem erros léxicos.");
            System.out.println("Lista de tokens:");
            System.out.println("\n" + tokenList);

            System.out.println("\nTabela de símbolos:");
            for (ArrayList<String> list : symbolTable.values()) {
                System.out.println("Símbolo: '" + list.get(0) + "', " + list.get(1) + " ocorrências");
            }
        }

        if (!hasSyntaxError) {
            System.out.println("\n>> Successo! Sem erros sintáticos.");
        }
    }

    private static void addTokenToList(String tokenName) {
        if (!tokenList.contains(tokenName)) {
            tokenList.add(tokenName);
        }
    }

    private static void addToSententialForm(String symbol, boolean terminal) {
       if (!sententialFormList.isEmpty()) {
           HashMap<String, Boolean> lastAddedToken = sententialFormList.get(sententialFormList.size() - 1);
           for (boolean isTerminal : lastAddedToken.values()) {
               if (!isTerminal) {
                   sententialFormList.remove(lastAddedToken);
                   removedTokens.add(lastAddedToken);
               }
           }
       }
       HashMap<String, Boolean> symbolMap = new HashMap<String, Boolean>();
       symbolMap.put(symbol, terminal);
    }
}

PARSER_END(MyParser)

SKIP : { " " | "\n" | "\r" | "\r\n" }

/* Palavras reservadas */
TOKEN:
{
  < INT: "int" >
| < FLOAT: "float" >
| < STRING: "string" >
| < DEF: "def" >
| < BREAK: "break" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < NEW: "new" >
| < NULL: "null" >
| < IF: "if" >
| < ELSE: "else" >
| < FOR: "for" >
}

/* Operadores */
TOKEN:
{
  < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < OPENP: "(">
| < CLOSEP: ")" >
| < OPENCB: "{" >
| < CLOSECB: "}" >
| < OPENB: "[" >
| < CLOSEB: "]" >
| < SEMIC: ";" >
| < COMMA: "," >
| < EQUALS: "==" >
| < ASSIGN: "=" >
| < GREAT: ">" >
| < LESS: "<" >
| < GREATEQ: ">=" >
| < LESSEQ: "<=" >
| < DIFF: "!=" >
| < MOD: "%" >
}

/* Identificadores */
TOKEN :
{
  <#LETTER: ["a" - "z", "A" - "Z"]>
| <#DIGIT: ["0"-"9"]>
| < ID: <LETTER> (<LETTER> | <DIGIT>)* >
| < INT_CONST: (<DIGIT>)+ >
| < FLOAT_CONST: (<DIGIT>)* "."(<DIGIT>)+ >
| < STRING_CONST: "\"" (~["\""])* "\"" >
}

// Produções
// (o "{}" representa a palavra vazia)
void program():
{}
{
    {addToSententialForm("program", false);}
    funclist() | statement() | {}<EOF>
}

void funclist():
{}
{
    {addToSententialForm("funclist", false);}
    funcdef() funclist2()
}

void funclist2():
{}
{
    {addToSententialForm("funclist2", false);}
    funclist() | {}
}

void funcdef():
{}
{
    {addToSententialForm("funcdef", false);}
    defToken() idToken("function") openpToken() paramlist() closepToken() opencbToken() statelist() closecbToken()
}

void paramlist():
{}
{
    {addToSententialForm("paramlist", false);}
    (intToken() | floatToken() | stringToken() ) idToken("parameter") commaToken() paramlist2() | {}
}

void paramlist2():
{}
{
    {addToSententialForm("paramlist2", false);}
    commaToken() paramlist() | {}
}

void statement():
{}
{
    {addToSententialForm("statement", false);}
    vardecl() semicToken() | atribstat() semicToken() | printstat() semicToken() | readstat() semicToken() | returnstat() semicToken() | ifstat() | forstat() | opencbToken() statelist() closecbToken() | breakToken() semicToken() | semicToken()
}

void vardecl():
{}
{
    {addToSententialForm("vardecl", false);}
    ( intToken() | floatToken() | stringToken()) idToken("variable") ic()
}

void ic():
{}
{
    {addToSententialForm("ic", false);}
    openbToken() intConstToken() closebToken() ic() | {}
}

void atribstat():
{}
{
    {addToSententialForm("atribstat", false);}
    lvalue() assignToken() (LOOKAHEAD(2) expression() | allocexpression() | funccal())
}

void funccal():
{}
{
    {addToSententialForm("funccal", false);}
    idToken("function") openpToken() paramlistcall() closepToken()
}

void paramlistcall():
{}
{
    {addToSententialForm("paramlistcall", false);}
    idToken("parameter") paramlistcall2() | {}
}

void paramlistcall2():
{}
{
    {addToSententialForm("paramlistcall2", false);}
    commaToken() paramlistcall() | {}
}

void printstat():
{}
{
    {addToSententialForm("printstat", false);}
    printToken() expression()
}

void readstat():
{}
{
    {addToSententialForm("readstat", false);}
    readToken() lvalue()
}

void returnstat():
{}
{
    {addToSententialForm("returnstat", false);}
    returnToken()
}

void ifstat():
{}
{
    {addToSententialForm("ifstat", false);}
    ifToken() openpToken() expression() closepToken() statement() es()
}

void es():
{}
{
    {addToSententialForm("es", false);}
    elseToken() statement() | {}
}

void forstat():
{}
{
    {addToSententialForm("forstat", false);}
    forToken() openpToken() atribstat() semicToken() expression() semicToken() atribstat() closepToken() statement()
}

void statelist():
{}
{
    {addToSententialForm("statelist", false);}
    statement() sl()
}

void sl():
{}
{
    {addToSententialForm("sl", false);}
    statelist() | {}
}

void allocexpression():
{}
{
    {addToSententialForm("allocexpression", false);}
    newToken() (intToken() | floatToken() | stringToken()) ne()
}

void ne():
{}
{
    {addToSententialForm("ne", false);}
    openbToken() numexpression() closebToken() (ne() | {})
}

void expression():
{}
{
    {addToSententialForm("numexpression", false);}
    numexpression() ned()
}

void ned():
{}
{
    {addToSententialForm("ned", false);}
    (lessToken() | greatToken() | lesseqToken() | greateqToken() | equalsToken() | diffToken() ) numexpression() | {}
}

void numexpression():
{}
{
    {addToSententialForm("numexpression", false);}
    term() ner()
}

void ner():
{}
{
    {addToSententialForm("ner", false);}
    (plusToken() | minusToken() ) term() ner() | {}
}

void term():
{}
{
    {addToSententialForm("term", false);}
    unaryexpr() ue()
}

void ue():
{}
{
    {addToSententialForm("ue", false);}
    (multToken() | divToken() | modToken() ) unaryexpr() ue() | {}
}

void unaryexpr():
{}
{
    {addToSententialForm("unaryexpr", false);}
    mn() factor()
}

void mn():
{}
{
    {addToSententialForm("mn", false);}
    plusToken() | minusToken() | {}
}

void factor():
{}
{
    {addToSententialForm("factor", false);}
    intConstToken() | floatConstToken() | stringConstToken() | nullToken() | lvalue() | openpToken() numexpression() closepToken()
}

void lvalue():
{}
{
    {addToSententialForm("lvalue", false);}
   idToken("lvalue") net()
}

void net():
{}
{
    {addToSententialForm("net", false);}
    openbToken() numexpression() closebToken() net() | {}
}


// A partir daqui há os tokens, que foram colocados em funções para que fosse possível executar código java
// quando cada um deles é encontrado pelo parser.

void idToken(String type):
{Token t;}
{
    t=<ID> {
    addToSententialForm("ID", true);
    tokenList.add("ID");

    if (symbolTable.containsKey(t.image)) {
        Integer symbolCount = Integer.valueOf(symbolTable.get(t.image).get(1));
        symbolCount++;
        symbolTable.get(t.image).set(1, symbolCount.toString());
    } else {
        ArrayList<String> data = new ArrayList<String>();
        data.add(t.image);
        data.add("1");
        symbolTable.put(t.image, data);
    }
}
}
void intToken():
{}
{
    {addToSententialForm("ID", true);}
    <INT> {tokenList.add("INT");
}
}
void floatToken():
{}
{
    {addToSententialForm("FLOAT", true);}
    <FLOAT> {tokenList.add("FLOAT");}
}
void stringToken():
{}
{
    {addToSententialForm("STRING", true);}
    <STRING> {tokenList.add("STRING");}
}
void defToken():
{}
{
    {addToSententialForm("DEF", true);}
    <DEF> {tokenList.add("DEF");}
}
void breakToken():
{}
{
    {addToSententialForm("BREAK", true);}
    <BREAK> {tokenList.add("BREAK");}
}
void printToken():
{}
{
    {addToSententialForm("PRINT", true);}
    <PRINT> {tokenList.add("PRINT");}
}
void readToken():
{}
{
    {addToSententialForm("READ", true);}
    <READ> {tokenList.add("READ");}
}
void returnToken():
{}
{
    {addToSententialForm("RETURN", true);}
    <RETURN> {tokenList.add("RETURN");}
}
void newToken():
{}
{
    {addToSententialForm("NEW", true);}
    <NEW> {tokenList.add("NEW");}
}
void nullToken():
{}
{
    {addToSententialForm("NULL", true);}
    <NULL> {tokenList.add("NULL");}
}
void ifToken():
{}
{
    {addToSententialForm("IF", true);}
    <IF> {tokenList.add("IF");}
}
void elseToken():
{}
{
    {addToSententialForm("ELSE", true);}
    <ELSE> {tokenList.add("ELSE");}
}
void forToken():
{}
{
    {addToSententialForm("FOR", true);}
    <FOR> {tokenList.add("FOR");}
}
void plusToken():
{}
{
    {addToSententialForm("PLUS", true);}
    <PLUS> {tokenList.add("PLUS");}
}
void minusToken():
{}
{
    {addToSententialForm("MINUS", true);}
    <MINUS> {tokenList.add("MINUS");}
}
void multToken():
{}
{
    {addToSententialForm("MULT", true);}
    <MULT> {tokenList.add("MULT");}
}
void divToken():
{}
{
    {addToSententialForm("DIV", true);}
    <DIV> {tokenList.add("DIV");}
}
void openpToken():
{}
{
    {addToSententialForm("OPENP", true);}
    <OPENP> {tokenList.add("OPENP");}
}
void closepToken():
{}
{
    {addToSententialForm("CLOSEP", true);}
    <CLOSEP> {tokenList.add("CLOSEP");}
}
void openbToken():
{}
{
    {addToSententialForm("OPENB", true);}
    <OPENB> {tokenList.add("OPENB");}
}
void closebToken():
{}
{
    {addToSententialForm("CLOSEB", true);}
    <CLOSEB> {tokenList.add("CLOSEB");}
}
void opencbToken():
{}
{
    {addToSententialForm("OPENCB", true);}
    <OPENCB> {tokenList.add("OPENCB");}
}
void closecbToken():
{}
{
    {addToSententialForm("CLOSECB", true);}
    <CLOSECB> {tokenList.add("CLOSECB");}
}
void semicToken():
{}
{
    {addToSententialForm("SEMIC", true);}
    <SEMIC> {tokenList.add("SEMIC");}
}
void commaToken():
{}
{
    {addToSententialForm("COMMA", true);}
    <COMMA> {tokenList.add("COMMA");}
}
void equalsToken():
{}
{
    {addToSententialForm("EQUALS", true);}
    <EQUALS> {tokenList.add("EQUALS");}
}
void assignToken():
{}
{
    {addToSententialForm("ASSIGN", true);}
    <ASSIGN> {tokenList.add("ASSIGN");}
}
void greatToken():
{}
{
    {addToSententialForm("GREAT", true);}
    <GREAT> {tokenList.add("GREAT");}
}
void greateqToken():
{}
{
    {addToSententialForm("GREATEQ", true);}
    <GREATEQ> {tokenList.add("GREATEQ");}
}
void lessToken():
{}
{
    {addToSententialForm("LESS", true);}
    <LESS> {tokenList.add("LESS");}
}
void lesseqToken():
{}
{
    {addToSententialForm("LESSEQ", true);}
    <LESSEQ> {tokenList.add("LESSEQ");}
}
void diffToken():
{}
{
    {addToSententialForm("DIFF", true);}
    <DIFF> {tokenList.add("DIFF");}
}
void modToken():
{}
{
    {addToSententialForm("MOD", true);}
    <MOD> {tokenList.add("MOD");}
}
void intConstToken():
 {}
 {
    {addToSententialForm("INT_CONST", true);}
     <INT_CONST> {tokenList.add("INT_CONST");}
 }
void floatConstToken():
 {}
 {
    {addToSententialForm("FLOAT_CONST", true);}
     <FLOAT_CONST> {tokenList.add("FLOAT_CONST");}
 }
void stringConstToken():
 {}
 {
    {addToSententialForm("STRING_CONST", true);}
     <STRING_CONST> {tokenList.add("STRING_CONST");}
 }