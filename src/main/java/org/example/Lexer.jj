// Grupo:
// - Cleberton Oliveira (17205083)
// - Gabriel Bristot Loli (20100844)
// - Kevin Rafael Velez Bernal (20102279)

options {
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(MyParser)
import org.example.CustomTree;import java.util.ArrayList;import java.util.HashMap;
import java.util.Map;

class MyParser {
    private static Map<String, ArrayList<String>> symbolTable;
    private static CustomTree customTree = new CustomTree();

  public static void main( String[] args ) throws ParseException, TokenMgrError {
        // Habilite essa opção para gerar o log da árvore sintática
        boolean debug = false;

        // Usados para saber se houve erros na execução
        boolean hasLexicalError = false;
        boolean hasSyntaxError = false;

        MyParser parser = new MyParser( System.in ) ;
        symbolTable = new HashMap<String, ArrayList<String>>();

        if (!debug) parser.disable_tracing();

        // Cabeçalho
        System.out.println("\n-------------------------------------------");
        System.out.println(">>> Trabalho feito por:");
        System.out.println("--> Cleberton Oliveira (17205083)");
        System.out.println("--> Gabriel Bristot Loli (20100844)");
        System.out.println("--> Kevin Rafael Velez Bernal (20102279)");
        System.out.println("-------------------------------------------\n");

        boolean emptyInput = false;
        try {
            // Executa o parser
            parser.program();
        } catch (ParseException e) {
            // Em caso de erro na análise sintática
            hasSyntaxError = true;
            if (parser.token == null) {
                emptyInput = true;
            } else {
                System.out.println("\nErro de análise sintática: " + e.getMessage());
                System.out.println("Falha na linha: " + e.currentToken.beginLine + ", coluna: " + e.currentToken.beginColumn);
                System.out.println("Forma sentencial alfa: " + customTree.getSententialForm());
                System.out.println("Símbolo não-terminal mais à esquerda de alfa: " + customTree.getLeftMostNonTerminal());
                System.out.println("Token da entrada que causou o erro: " + e.currentToken.image + "\n");
            }
        } catch (TokenMgrError e) {
            // Em caso de erro na análise léxica
            hasLexicalError = true;
            System.out.println("\nErro de análise léxica: " + e.getMessage());
        }

        if (emptyInput) {
            System.out.println("Erro de análise sintática: entrada vazia na tabela de reconhecimento");
        }

        if (!hasLexicalError) {
            System.out.println("\n>> Successo! Sem erros léxicos.");
            System.out.println("Lista de tokens:");
            System.out.println("\n" + customTree.getLeafNodeNamesList());

            System.out.println("\nTabela de símbolos:");
            for (ArrayList<String> list : symbolTable.values()) {
                System.out.println("Símbolo: '" + list.get(0) + "', " + list.get(1) + " ocorrências");
            }
        }

        if (!hasSyntaxError) {
            System.out.println("\n>> Successo! Sem erros sintáticos.");
        }
    }
}

PARSER_END(MyParser)

SKIP : { " " | "\n" | "\r" | "\r\n" }

/* Palavras reservadas */
TOKEN:
{
  < INT: "int" >
| < FLOAT: "float" >
| < STRING: "string" >
| < DEF: "def" >
| < BREAK: "break" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < NEW: "new" >
| < NULL: "null" >
| < IF: "if" >
| < ELSE: "else" >
| < FOR: "for" >
}

/* Operadores */
TOKEN:
{
  < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < DIV: "/" >
| < OPENP: "(">
| < CLOSEP: ")" >
| < OPENCB: "{" >
| < CLOSECB: "}" >
| < OPENB: "[" >
| < CLOSEB: "]" >
| < SEMIC: ";" >
| < COMMA: "," >
| < EQUALS: "==" >
| < ASSIGN: "=" >
| < GREAT: ">" >
| < LESS: "<" >
| < GREATEQ: ">=" >
| < LESSEQ: "<=" >
| < DIFF: "!=" >
| < MOD: "%" >
}

/* Identificadores */
TOKEN :
{
  <#LETTER: ["a" - "z", "A" - "Z"]>
| <#DIGIT: ["0"-"9"]>
| < ID: <LETTER> (<LETTER> | <DIGIT>)* >
| < INT_CONST: (<DIGIT>)+ >
| < FLOAT_CONST: (<DIGIT>)* "."(<DIGIT>)+ >
| < STRING_CONST: "\"" (~["\""])* "\"" >
}

// Produções
// (o "{}" representa a palavra vazia)
void program():
{}
{
    {customTree.addTokenToList("program", false);}
    funclist() | statement() | {}<EOF>
}

void funclist():
{}
{
    {customTree.addTokenToList("funclist", false);}
    funcdef() funclist2()
}

void funclist2():
{}
{
    {customTree.addTokenToList("funclist2", false);}
    funclist() | {}
}

void funcdef():
{}
{
    {customTree.addTokenToList("funcdef", false);}
    defToken() idToken("function") openpToken() paramlist() closepToken() opencbToken() statelist() closecbToken()
}

void paramlist():
{}
{
    {customTree.addTokenToList("paramlist", false);}
    (intToken() | floatToken() | stringToken() ) idToken("parameter") commaToken() paramlist2() | {}
}

void paramlist2():
{}
{
    {customTree.addTokenToList("paramlist2", false);}
    commaToken() paramlist() | {}
}

void statement():
{}
{
    {customTree.addTokenToList("statement", false);}
    vardecl() semicToken() | atribstat() semicToken() | printstat() semicToken() | readstat() semicToken() | returnstat() semicToken() | ifstat() | forstat() | opencbToken() statelist() closecbToken() | breakToken() semicToken() | semicToken()
}

void vardecl():
{}
{
    {customTree.addTokenToList("vardecl", false);}
    ( intToken() | floatToken() | stringToken()) idToken("variable") ic()
}

void ic():
{}
{
    {customTree.addTokenToList("ic", false);}
    openbToken() intConstToken() closebToken() ic() | {}
}

void atribstat():
{}
{
    {customTree.addTokenToList("atribstat", false);}
    lvalue() assignToken() (LOOKAHEAD(2) expression() | allocexpression() | funccal())
}

void funccal():
{}
{
    {customTree.addTokenToList("funccal", false);}
    idToken("function") openpToken() paramlistcall() closepToken()
}

void paramlistcall():
{}
{
    {customTree.addTokenToList("paramlistcall", false);}
    idToken("parameter") paramlistcall2() | {}
}

void paramlistcall2():
{}
{
    {customTree.addTokenToList("paramlistcall2", false);}
    commaToken() paramlistcall() | {}
}

void printstat():
{}
{
    {customTree.addTokenToList("printstat", false);}
    printToken() expression()
}

void readstat():
{}
{
    {customTree.addTokenToList("readstat", false);}
    readToken() lvalue()
}

void returnstat():
{}
{
    {customTree.addTokenToList("returnstat", false);}
    returnToken()
}

void ifstat():
{}
{
    {customTree.addTokenToList("ifstat", false);}
    ifToken() openpToken() expression() closepToken() statement() es()
}

void es():
{}
{
    {customTree.addTokenToList("es", false);}
    elseToken() statement() | {}
}

void forstat():
{}
{
    {customTree.addTokenToList("forstat", false);}
    forToken() openpToken() atribstat() semicToken() expression() semicToken() atribstat() closepToken() statement()
}

void statelist():
{}
{
    {customTree.addTokenToList("statelist", false);}
    statement() sl()
}

void sl():
{}
{
    {customTree.addTokenToList("sl", false);}
    statelist() | {}
}

void allocexpression():
{}
{
    {customTree.addTokenToList("allocexpression", false);}
    newToken() (intToken() | floatToken() | stringToken()) ne()
}

void ne():
{}
{
    {customTree.addTokenToList("ne", false);}
    openbToken() numexpression() closebToken() (ne() | {})
}

void expression():
{}
{
    {customTree.addTokenToList("numexpression", false);}
    numexpression() ned()
}

void ned():
{}
{
    {customTree.addTokenToList("ned", false);}
    (lessToken() | greatToken() | lesseqToken() | greateqToken() | equalsToken() | diffToken() ) numexpression() | {}
}

void numexpression():
{}
{
    {customTree.addTokenToList("numexpression", false);}
    term() ner()
}

void ner():
{}
{
    {customTree.addTokenToList("ner", false);}
    (plusToken() | minusToken() ) term() ner() | {}
}

void term():
{}
{
    {customTree.addTokenToList("term", false);}
    unaryexpr() ue()
}

void ue():
{}
{
    {customTree.addTokenToList("ue", false);}
    (multToken() | divToken() | modToken() ) unaryexpr() ue() | {}
}

void unaryexpr():
{}
{
    {customTree.addTokenToList("unaryexpr", false);}
    mn() factor()
}

void mn():
{}
{
    {customTree.addTokenToList("mn", false);}
    plusToken() | minusToken() | {}
}

void factor():
{}
{
    {customTree.addTokenToList("factor", false);}
    intConstToken() | floatConstToken() | stringConstToken() | nullToken() | lvalue() | openpToken() numexpression() closepToken()
}

void lvalue():
{}
{
    {customTree.addTokenToList("lvalue", false);}
   idToken("lvalue") net()
}

void net():
{}
{
    {customTree.addTokenToList("net", false);}
    openbToken() numexpression() closebToken() net() | {}
}


// A partir daqui há os tokens, que foram colocados em funções para que fosse possível executar código java
// quando cada um deles é encontrado pelo parser.

void idToken(String type):
{Token t;}
{
    t=<ID> {
    customTree.addTokenToList("ID", true, t.image);

    if (symbolTable.containsKey(t.image)) {
        Integer symbolCount = Integer.valueOf(symbolTable.get(t.image).get(1));
        symbolCount++;
        symbolTable.get(t.image).set(1, symbolCount.toString());
    } else {
        ArrayList<String> data = new ArrayList<String>();
        data.add(t.image);
        data.add("1");
        symbolTable.put(t.image, data);
    }
}
}
void intToken():
{Token t;}
{
    t=<INT> {customTree.addTokenToList("INT", true, t.image);}
}
void floatToken():
{Token t;}
{
    t=<FLOAT> {customTree.addTokenToList("FLOAT", true, t.image);}
}
void stringToken():
{Token t;}
{
    t=<STRING> {customTree.addTokenToList("STRING", true, t.image);}
}
void defToken():
{Token t;}
{
    t=<DEF> {customTree.addTokenToList("DEF", true, t.image);}
}
void breakToken():
{Token t;}
{
    t=<BREAK> {customTree.addTokenToList("BREAK", true, t.image);}
}
void printToken():
{Token t;}
{
    t=<PRINT> {customTree.addTokenToList("PRINT", true, t.image);}
}
void readToken():
{Token t;}
{
    t=<READ> {customTree.addTokenToList("READ", true, t.image);}
}
void returnToken():
{Token t;}
{
    t=<RETURN> {customTree.addTokenToList("RETURN", true, t.image);}
}
void newToken():
{Token t;}
{
    t=<NEW> {customTree.addTokenToList("NEW", true, t.image);}
}
void nullToken():
{Token t;}
{
    t=<NULL> {customTree.addTokenToList("NULL", true, t.image);}
}
void ifToken():
{Token t;}
{
    t=<IF> {customTree.addTokenToList("IF", true, t.image);}
}
void elseToken():
{Token t;}
{
    t=<ELSE> {customTree.addTokenToList("ELSE", true, t.image);}
}
void forToken():
{Token t;}
{
    t=<FOR> {customTree.addTokenToList("FOR", true, t.image);}
}
void plusToken():
{Token t;}
{
    t=<PLUS> {customTree.addTokenToList("PLUS", true, t.image);}
}
void minusToken():
{Token t;}
{
    t=<MINUS> {customTree.addTokenToList("MINUS", true, t.image);}
}
void multToken():
{Token t;}
{
    t=<MULT> {customTree.addTokenToList("MULT", true, t.image);}
}
void divToken():
{Token t;}
{
    t=<DIV> {customTree.addTokenToList("DIV", true, t.image);}
}
void openpToken():
{Token t;}
{
    t=<OPENP> {customTree.addTokenToList("OPENP", true, t.image);}
}
void closepToken():
{Token t;}
{
    t=<CLOSEP> {customTree.addTokenToList("CLOSEP", true, t.image);}
}
void openbToken():
{Token t;}
{
    t=<OPENB> {customTree.addTokenToList("OPENB", true, t.image);}
}
void closebToken():
{Token t;}
{
    t=<CLOSEB> {customTree.addTokenToList("CLOSEB", true, t.image);}
}
void opencbToken():
{Token t;}
{
    t=<OPENCB> {customTree.addTokenToList("OPENCB", true, t.image);}
}

void closecbToken():
{Token t;}
{
    t=<CLOSECB> {customTree.addTokenToList("CLOSECB", true, t.image);}
}
void semicToken():
{Token t;}
{
    t=<SEMIC> {customTree.addTokenToList("SEMIC", true, t.image);}
}

void commaToken():
{Token t;}
{
    t=<COMMA> {customTree.addTokenToList("COMMA", true, t.image);}
}
void equalsToken():
{Token t;}
{
    t=<EQUALS> {customTree.addTokenToList("EQUALS", true, t.image);}
}
void assignToken():
{Token t;}
{
    t=<ASSIGN> {customTree.addTokenToList("ASSIGN", true, t.image);}
}
void greatToken():
{Token t;}
{
    t=<GREAT> {customTree.addTokenToList("GREAT", true, t.image);}
}
void greateqToken():
{Token t;}
{
    t=<GREATEQ> {customTree.addTokenToList("GREATEQ", true, t.image);}
}
void lessToken():
{Token t;}
{
    t=<LESS> {customTree.addTokenToList("LESS", true, t.image);}
}
void lesseqToken():
{Token t;}
{
    t=<LESSEQ> {customTree.addTokenToList("LESSEQ", true, t.image);}
}
void diffToken():
{Token t;}
{
    t=<DIFF> {customTree.addTokenToList("DIFF", true, t.image);}
}
void modToken():
{Token t;}
{
    t=<MOD> {customTree.addTokenToList("MOD", true, t.image);}
}
void intConstToken():
 {Token t;}
 {
     t=<INT_CONST> {customTree.addTokenToList("INT_CONST", true, t.image);}
 }
void floatConstToken():
 {Token t;}
 {
     t=<FLOAT_CONST> {customTree.addTokenToList("FLOAT_CONST", true, t.image);}
 }
void stringConstToken():
 {Token t;}
 {
     t=<STRING_CONST> {customTree.addTokenToList("STRING_CONST", true, t.image);}
 }